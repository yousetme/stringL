var Set = Set || {};//优化性能，了解每一个作用后的机理
Set.debug = true;
(function() {
    Set.Loader = {
        block: 0,
        require: function(missingClasses, callback) {
            if(missingClasses.length==0) {
                callback.call(this);
                return;
            }

            Set.each(missingClasses, function(key, value) {
                require(value.split('.').join('/')+'.js');
            });
            callback();
        }
    };

    Set.detectPathDeadLock = function(className, deps) {
        var deadlockPath = [], //死锁路径
            detectDeadlock, dep, requiredMap,
            Loader = Set.Loader,
            _requiresMap = {};

        if (className) {
            _requiresMap[className] = deps; //建立依赖结构
            requiredMap = Loader.requiredByMap || (Loader.requiredByMap = {});
            for (i = 0,ln = deps.length; i < ln; i++) {
                dep = deps[i];
                (requiredMap[dep] || (requiredMap[dep] = [])).push(className);//依赖不存在初始化为数组，推入类名
            }

            detectDeadlock = function(cls) {
                deadlockPath.push(cls);
                if (_requiresMap[cls]) {

                    if (Set.contains(_requiresMap[cls], className)) {//
                        Set.Logger.error("Circular requirement detected! '" + className +
                            "' and '" + deadlockPath[0] + "' mutually require each other. Path: " +
                            deadlockPath.join(' -> ') + " -> " + deadlockPath[0]);
                    }
                    for (i = 0,ln = _requiresMap[cls].length; i < ln; i++) {//检测每一个类是否存在循环引用
                        detectDeadlock(_requiresMap[cls][i]);
                    }
                }
            }
        };

        detectDeadlock(className);
    };
})();

(function() {
    Set.UUID = 0;
    Set.getUUID = function() {
        return Set.UUID++;
    }
    Set.namespace = function(nsp, C) {
        var root = global,
            parts = nsp.split('.'),
            ln = parts.length - 1,
            leaf = parts[ln],
            i, part;

        for (i = 0; i < ln; i++) {
            part = parts[i];
            if (!root[part]) {
                root[part] = {};
            }
            root = root[part];
        }
        root[leaf] = C || {};
        return root[leaf];
    }

    Set.extend = function(target, copy, override) {
        if(typeof target == 'string') target = Set.namespace(target);
        if(target) for (var i in copy) if(override!=false || target[i]===undefined) target[i] = copy[i];
        return target;
    };

    Set.each = function(array, cb) {
        for(var i= 0,ln=array.length; i<ln; i++) cb.call(this, i, array[i]);
    }

    Set.Try = function(callback) {
        try {
            return callback.apply(this, arguments);
        } catch(e) {}
    }

    Set.contains = 'indexOf' in Array.prototype ? function(array, item) {
        return Array.prototype.indexOf.call(array, item) !== -1;
    } : function(array, item) {
        var i, ln;
        for (i = 0, ln = array.length; i < ln; i++) {
            if (array[i] === item) {
                return true;
            }
        }
        return false;
    }

    Set.Logger = {
        log: function(message, priority) {
            var global = window;
            if (message && global.console) {
                if (!priority || !(priority in global.console)) {
                    priority = 'log';
                }
                message = '[' + priority.toUpperCase() + '] ' + message;
                global.console[priority](message);
            }
        },
        verbose: function(message) {
            this.log(message, 'verbose');
        },
        info: function(message) {
            this.log(message, 'info');
        },
        warn: function(message) {
            this.log(message, 'warn');
        },
        error: function(message) {
            throw new Error(message);
        }
    }
})();

(function() {
    //数据类型扩展
    var class2type = {},
        toString = class2type.toString;
    Set.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
        class2type["[object " + name + "]"] = name.toLowerCase();
    });
    Set.extend(Set, {
        type: function(obj) {
            if(obj == null) return obj + "";
            return typeof obj === "object" || typeof obj === "function" ?
                class2type[toString.call(obj)] || "object" : typeof obj;
        },

        isFunction: function( obj ) {
            return Set.type(obj) === "function";
        },

        isArray: Array.isArray || function( obj ) {
            return Set.type(obj) === "array";
        },

        isBoolean: function(obj) {
            return Set.type(obj) === 'boolean';
        },

        isNumber: function(obj) {
            return Set.type(obj) === 'number' && isFinite(obj);
        },

        isNumeric: function( obj ) {
            return !Set.isArray( obj ) && obj - parseFloat( obj ) >= 0;
        },

        isString: function(obj) {
            return Set.type(obj) === 'string';
        },


        isDate: function(obj) {
            return Set.type(obj) === 'date';
        },

        isObject: (toString.call(null) === '[object Object]') ?
            function(obj) {
                return obj !== null && obj !== undefined && Set.type(obj) === 'object' && obj.ownerDocument === undefined;
            } : function(obj) {
            return Set.type(obj) === 'object';
        },

        isEmptyObject: function(obj) {
            var name;
            for(name in obj) return false;
            return true;
        },

        isSimpleObject: function(obj) {
            return obj instanceof Object && obj.constructor === Object;
        },

        isWindow: function( obj ) {
            return obj != null && obj == obj.window;
        },

        isPrimitive: function(obj) {
            var type = Set.type(obj);
            return type === 'string' || type === 'number' || type === 'boolean';
        },

        isDefined: function(value) {
            return typeof value !== 'undefined';
        },

        isEmpty: function(obj, allowEmptyString) {
            return (obj == null) || (!allowEmptyString ? obj === '' : false) || (Set.isArray(obj) && obj.length === 0) || Set.isEmptyObject(obj);
        },

        globalEval: function(data) {
            if (data && Set.trim(data)) {
                (window.execScript || function(data) {
                    window["eval"].call(window, data);
                })(data);
            }
        },
        // Support: Android<4.1, IE<9
        trim: function(text) {
            return text == null ? "" :( text + "" ).replace( /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
        },
        obj2str: function(o) {
            if (o == undefined) {
                return "";
            }
            var r = [];
            if (typeof o == "string") return "\"" + o.replace(/([\"\\])/g, "\\$1").replace(/(\n)/g, "\\n").replace(/(\r)/g, "\\r").replace(/(\t)/g, "\\t") + "\"";
            if (typeof o == "object") {
                if (!o.sort) {
                    for (var i in o)
                        r.push("\"" + i + "\":" + Set.obj2str(o[i]));
                    if (!!global.all && !/^\n?function\s*toString\(\)\s*\{\n?\s*\[native code\]\n?\s*\}\n?\s*$/.test(o.toString)) {
                        r.push("toString:" + o.toString.toString());
                    }
                    r = "{" + r.join() + "}"
                } else {
                    for (var i = 0; i < o.length; i++)
                        r.push(Set.obj2str(o[i]))
                    r = "[" + r.join() + "]";
                }
                return r;
            }
            return o.toString().replace(/\"\:/g, '":""');
        }
    });
})();

(function() {
    Set.extend(Set, {
        each: function(obj, callback, args) {
            var i = 0,
                length = obj.length,
                isArray = Set.isArray( obj );

            if (args) {
                if ( isArray ) {
                    for ( ; i < length; i++ ) if (callback.apply( obj[ i ], args )=== false) break;
                } else {
                    for ( i in obj ) if (callback.apply( obj[ i ], args )=== false) break;
                }
            } else {
                if (isArray) {
                    for ( ; i < length; i++ ) if (callback.call(obj[ i ], i, obj[ i ]) === false) break;
                } else {
                    for (i in obj) if (callback.call(obj[ i ], i, obj[ i ]) === false) break;
                }
            }
            return obj;
        }
    });
})();
//封装消息机制
//封装类系统
//封装队列机制
(function() {
    var Base = function(){};//基类
    Base.prototype = {
        className:"Set.Base",
        Parent: null,
        constructor: function() {
            return this;
        }
    };

    var CF = function(className, d) {
        if(!d) d = {};
        var C = CF.mkCtor(d, className);
        CF.process(C, d);
        return C;
    };

    Set.extend(CF, {
        classes:{},
        cps:{},
        cpsStack:[],//classProcessorsStack
        tplClass: function() {},
        mkCtor: function(d, className) {
            if(!d.hasOwnProperty('constructor')) {
                d.constructor = function() {
                    if(this.Parent) this.Parent.apply(this.Parent, arguments);
                };
            }
            d.constructor.ClassName = className;
            return d.constructor;
        },
        process: function(C, d) {
            var cpsStack = [],
                hooks = {};
            Set.each(CF.cpsStack, function(key, value) {
                cpsStack.push(value);
            });
            hooks.cpsStack = cpsStack;
            CF.doProcess(C, d, hooks, CF.doProcess);
        },
        doProcess: function(C, d, hooks, chain) {//可以自定义builder d.classProcessor 可以重新设置流水线工人的位置
            var cpsStatck = hooks.cpsStack,
                cps = CF['cps'],
                clsName = CF.getClassName(C);
            for (var cp=cpsStatck.shift(); cp ; cp=cpsStatck.shift()) {
                if(cps[cp]['fn'].apply(CF, arguments) === false) return;//显示的false结束，注意只有Loader才返回false
            }
            //注意重复添加的问题
            CF.addMembers(C, d);//所有扩展的属性都已经删除，添加剩余的属性。结束处理
            if(clsName) CF.regClass(clsName, C);
        },
        addMembers: function (C, members, isStatic) {
            var member,
                target = isStatic ? C : C.prototype;
            for(name in members) {
                if(members.hasOwnProperty(name)) {
                    member = members[name];
                    target[name] = member;
                }
            }
            return this;
        },
        addCp: function(name, cp) {
            CF.cps[name] = cp;
            CF.cpsStack.push(name);
        },
        mixins: function(C, name, mixinClass) {
            var mixin, prototype, key, i, ln, mixinValue, mixins;

            if (typeof name !== 'string') {
                mixins = name;
                if (mixins instanceof Array) {
                    for (i = 0,ln = mixins.length; i < ln; i++) {
                        mixin = mixins[i];
                        this.mixins(C, mixin.ClassName, mixin);
                    }
                } else {
                    for (var mixinName in mixins) {
                        this.mixins(C, mixinName, mixins[mixinName]);
                    }
                }
                return;
            }

            mixin = mixinClass.prototype;
            prototype = C.prototype;
            if(!prototype.hasOwnProperty('mixins')) {
                if ('mixins' in prototype) {
                    prototype.mixins = CF.chain(prototype.mixins);
                } else {
                    prototype.mixins = {};
                }
            }

            for (key in mixin) {//copy 成员
                mixinValue = mixin[key];
                if (key === 'mixins') {
                    Set.extend(prototype.mixins, mixinValue, false);
                } else if (prototype[key] === undefined) {
                    prototype[key] = mixinValue;
                }
            }

            prototype.mixins[name] = mixin;
            return C;
        },
        chain: function (proto) {
            CF.tplClass.prototype = proto;
            var newPrototype = new CF.tplClass();
            CF.tplClass.prototype = null;
            return newPrototype;
        },

        regClass: function(className, C) {//存在要报错处理
            if(CF.classes[className]) Set.Logger.error('Class have exists of <'+className+'>.');
            CF.classes[className] = Set.namespace(className, C);
        },

        getClass: function(className) {
            var C = CF.classes[className];
            if(!C) Set.Logger.error('Class <'+className+'> not exists.');
            return C;
        },

        getClassName: function(object) {
            return object && object.ClassName || '';
        },

        filterUnloadedClass: function(classNames) {
            var missingClassNames = [],
                className;
            for (var i = 0, ln=classNames.length; i < ln; i++) {
                className = CF.classes[classNames[i]];
                if (!className) {
                    missingClassNames.push(classNames[i]);
                }
            }
            return missingClassNames;
        }
    });

    CF.addCp('load', {
        name: 'load',
        fn: function(C, d, hooks, chain) {
            var me = this,
                deps = [],
                i, j, ln, subLn, value, attrName, attrValue;
            var depAttrs = ['extend', 'mixins', 'requires'];
            for(i = 0,ln = depAttrs.length; i < ln; i++) {//依赖处理
                attrName = depAttrs[i];//当前处理依赖
                if(d.hasOwnProperty(attrName)) {//检测类定义是否有这个配置
                    attrValue = d[attrName];//配置内容
                    if(typeof attrValue == 'string') {//字符类型为依赖
                        deps.push(attrValue);
                    } else if(attrValue instanceof Array) {//多个依赖
                        for(j = 0, subLn = attrValue.length; j < subLn; j++) {
                            value = attrValue[j];
                            if(typeof value == 'string') {
                                deps.push(value);
                            }
                        }
                    }
                }
            }

            var depsToCls = function() {
                for (i = 0,ln = depAttrs.length; i < ln; i++) {//遍历依赖数组
                    attrName = depAttrs[i];
                    if (d.hasOwnProperty(attrName)) {//与data属性做比较，一致则向下处理
                        attrValue = d[attrName];//属性值：属性名
                        if (typeof attrValue == 'string') {
                            d[attrName] = CF.getClass(attrValue); //将data相应的依赖换成类对象
                        } else if (attrValue instanceof Array) {
                            for (j = 0, subLn = attrValue.length; j < subLn; j++) {
                                value = attrValue[j];
                                if (typeof value == 'string') {
                                    d[attrName][j] = CF.getClass(value);
                                }
                            }
                        }
                    }
                }
                chain.call(me, C, d, hooks);
            }

            if(deps.length === 0) return; //如果没有依赖则返回
            if(Set.debug) {
                Set.detectPathDeadLock(CF.getClassName(C), deps);
                Set.Loader.require(CF.filterUnloadedClass(deps), depsToCls);
            } else depsToCls();

            return false;
        }
    });

    CF.addCp('extend', {
        name: 'extend',
        properties: false,
        fn: function(C, d) {
            var extend = d.extend,
                Parent;

            delete d.extend;
            Parent = extend ? extend : Base;
            C.prototype = CF.chain(Parent.prototype);
            C.prototype.constructor = C;
            C.prototype.Parent = Parent;
            C.Parent = Parent;
            C.CF = CF;
        }
    });

    CF.addCp('statics', {
        name: 'statics',
        fn: function(C, d) {
            var statics = d.statics;
            if(!statics) return;
            delete d.statics;
            CF.addMembers(C, statics, true);
        }
    });

    CF.addCp('mixins', {
        name: 'mixins',
        fn: function(C, d) {
            var mixins = d.mixins;
            if(!mixins) return;
            delete d.mixins;
            CF.mixins(C, mixins);
        }
    });

    Set.extend(Set, {
        Class: function(clsNames, d) {
            if(!Set.isString(clsNames)) d = clsNames, clsNames = '';
            return CF(clsNames, d);
        },
        New: function(className) {
            var C =  CF.getClass(className), args = [];
            for (var i = 1, ln=arguments.length; i < ln; i++) {
                args.push('a[' + i + ']');
            }
            var c = new Function('c', 'a', 'return new c(' + args.join(',') + ')');
            return c(C, arguments);
        }
    });
})();
/*

var C = Class('jh.Person', {
    name: 'name',
    constructor: function (config) {
        console.log(config.name);
    },
    getName: function () {
        return this.name;
    }*/
/*,
     extend:['jh.People']*//*

});

new C({
    name:'hello world'
});
*/

//module.exports = Set;

global.Set = Set;
global.Class = Set.Class;
global.New = Set.New;
