Set.Class('classes.compile.Lexer', {
    requires: ['classes.compile.Constants', 'classes.compile.Node'],

    constructor: function(text, file) {
        this.file = file;
        this.text = text;
        this.line = 1;
        this.col = 1;
        this.start = 0,
        this.offset = 0;
        this.constants = classes.compile.Constants;
        this.tokens = [];
        this.ast = null;
    },

    isIdentifierChar: function(value) {
        return /[A-Za-z0-9]/.test(value);
    },

    scanKeyword: function() {
        var me = this, startLine = me.line, startCol = me.col, text = me.text, textLength = text.length;
        while(me.offset < textLength && me.isIdentifierChar(text.charAt(me.offset))) {
            me.forward();
        }

        var content = text.substring(me.start, me.offset);//如果命令不存在，直接报错
        if(content == '') throw new Error('fn not exists');
        return New('classes.compile.Node', content, me.file, me.start, me.offset, startLine, startCol);
    },

    parse: function() {
        var me = this
            constants = me.constants,
            text = me.text, textLength = text.length,
            cur = '';

        while(me.offset < textLength) {
            cur = text.charAt(me.offset) + text.charAt(me.offset + 1);
            if(constants.isOpenDelimiter(cur)) {
                me.tokens.push(New('classes.compile.Node', 'str', me.file, me.start, me.offset, me.line, me.col));
                me.tokens.push(New('classes.compile.Node', 'open', me.file, me.offset, me.offset + 1, me.line, me.col, constants.TYPE_OPEN));
                me.skip(2);
                me.skipSpaces();
                me.start = me.offset;
                me.tokens.push(me.scanKeyword());
                me.start = me.offset;
            } else {
                if(constants.isCloseDelimiter(cur)) {
                    me.tokens.push(New('classes.compile.Node', 'str', me.file, me.start, me.offset, me.line, me.col));
                    me.tokens.push(New('classes.compile.Node', 'close', me.file, me.offset, me.offset + 1, me.line, me.col, constants.TYPE_CLOSE));
                    me.start = me.offset + 2;
                }
                me.forward();
            }
        }

        this.cAST();
    },

    cAST: function() {
        var me = this,
            constants = me.constants,
            tokens = me.tokens,
            stack = [],
            last, curr, newNode = null;

        while(curr = tokens.shift()) {
            if(curr.type == constants.TYPE_CLOSE) {
                while(true) {
                    last = stack.pop();
                    if(last == null) {
                       throw new Error(Set.obj2str(curr));
                    } else if(last.type == constants.TYPE_OPEN) {
                        newNode.tp = newNode.hp;
                        newNode.hp.fn = 'cmdstr';
                        newNode.hp = null;
                        stack.push(newNode);
                        newNode = null;
                        break;
                    } else { //挂接
                        last.hp = newNode;
                        newNode = last;
                    }
                }
            } else {
                stack.push(curr);
            }
        }
        this.ast = stack[1];
    },

    forward: function() {
        var me = this;
        if (me.text.charAt(me.offset) == '\n') {
            me.line++;
            me.col = 1;
            me.offset++;
        } else {
            me.col++;
            me.offset++;
        }
    },

    skip: function(n) {
        for (var i = 0; i < n; i++) {
            this.forward();
        }
    },

    skipSpaces: function() {
        var me = this, textLength = me.text.length, text = me.text;
        while (me.offset < textLength &&  me.isWhitespace(text.charAt(me.offset))) {
            me.forward();
        }
    },

    isWhitespace:function(c) {
        return /\s/.test(c);
    }
});
