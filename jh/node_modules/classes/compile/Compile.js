'use strict';
function compress(text) {
    return trim(text.replace(/[ \n\v\f\r\t]+/g, " ") .replace(/<!--.*?-->/g, ''));
}

function trim(text) {
    if(String.prototype.trim && !String.prototype.trim.call("\uFEFF\xA0")) {
        return text == null ? "" : String.prototype.trim.call(text);
    } else {
        var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
        return text == null ? "" : ( text + "" ).replace(rtrim, "");
    }
}

function isEChar(c) {
    return /\s/.test(c);
}

function stringify(code) {
    return '"' + code
        // 单引号与反斜杠转义
        .replace(/("|\\)/g, '\\$1')
        // 换行符转义(windows + linux)
        .replace(/\r/g, '\\r')
        .replace(/\n/g, '\\n') + '"';
}


var Tpl = Set.Class('class.compile.Compile', {
    constructor: function() {
        //this.mapFn = 'mapPhpCode';
    },
    isCompress: false,
    bound:{left:'{', right:'}'},
    boundChar: '%',
    command: {cond:1, str:1, echo:1, getv:1, code:1, for:0, foreach:0, if:3, elseif:3, else:3,
        html:0, block:0, head:0, body:0, phpend:0, script:1, file:1},
    mapFn: 'mapPhpTag',

    replaces: ["$out='';", "$out.=", ";\n", "$out"],
    jsReplaces: ''.trim ? ["$out='';", "$out+=", ";", "$out"] : ["$out=[];", "$out.push(", ");", "$out.join('')"],
    concat: ''.trim ? "if(content!==undefined){$out+=content;return content;}" : "$out.push(content);",

    code: '',
    line:0,
    offset:0,
    col:0,

    compile: function(code, parent) {
        this.code = code;
        this.parent = parent;
        var tokens = this.parseSyntax(code);
        return this.t(tokens[1]);
    },

    render: function (id, data) {
        var cache = template.get(id) || _debug({
            id: id,
            name: 'Render Error',
            message: 'No Template'
        });
        return cache(data);
    },
    mapPhpCode: function(gl, tpl) {
        var replaces = this.replaces,
            code = this.code;
        switch (gl.fn) {
            /*            case 'str':
             tpl = compress(code.substring(gl.begin, gl.forward));
             break;*/
            case 'phpopen':
                tpl = tpl + "<?php\n" ;+ tpl
                break;
            case 'getv':
                tpl = replaces[1] + this.cmdBody(gl) + replaces[2];
                break;
            case 'echo':
                if(trim(code.substring(gl.begin, gl.forward))=='') tpl = '';
                else
                    tpl = replaces[1] + stringify(compress(code.substring(gl.begin, gl.forward))) + replaces[2];
                break;
            case 'for':
                tpl = "for(" + this.cmdBody(gl.tp.hp) + ') {' + tpl + "}";
                break;
            /*            case 'cond':
             tpl = "(" + tpl +") {";
             break;*/
            case 'if':
                tpl = "if(" + this.cmdBody(gl.tp.hp) + ') {' + tpl + "}";
                break;
            case 'elseif':
                tpl = "else if(" + this.cmdBody(gl.tp.hp) + ') {' + tpl + "} ";
                break;
            case 'else':
                tpl = "else(" + this.cmdBody(gl.tp.hp) + ') {' + tpl + "} ";
                break;
            case 'file': break;
            case 'script':
                tpl = replaces[1] + stringify("<script>") + replaces[2] + tpl + replaces[1] + stringify("</script>") + replaces[2];
                break;
            case 'body':
                tpl = replaces[1] + stringify("<body>") + replaces[2] + tpl +  replaces[1] + stringify("</body>") + replaces[2];
                break;
            case 'head':
                tpl = replaces[1] + stringify("<head>") + replaces[2] + tpl + replaces[1] +stringify("</head>") + replaces[2];
                break;
            case 'html':
                tpl = replaces[1] + stringify("<html>") + replaces[2] + tpl + replaces[1] + stringify("</html>") + replaces[2];
                break;
            case 'script':
                tpl = replaces[1] + stringify("<script>") + replaces[2] + tpl + replaces[1] + stringify("</script>") + replaces[2];
                break;
            case 'block':
                break;
            case 'code':
                tpl = compress(this.cmdBody(gl));
                break;
            default : break;
        }

        return tpl;
    },
    map1cmd: function(gl, tpl) {
        var code = this.code;
        switch (gl.fn) {
            case 'str':
                tpl = code.substring(gl.begin, gl.forward) ;//+ tpl
                break;
            case 'cond':
                break;
            case 'block':
                break;
            default : break;
        }

        return tpl;
    },
    mapPhpTag: function(gl, tpl) {
        var replaces = this.replaces,
            code = this.code,
            end = this.end;
        switch (gl.fn) {
            case 'phpend':
                tpl = tpl + "?>" ;+ tpl
                break;
            case 'getv':
                tpl = "<?php echo " + this.cmdBody(gl) + "; ?>";
                break;
            case 'echo':
                tpl = code.substring(gl.begin, gl.forward) ;
                break;
            case 'for':
                tpl = "<?php for(" + this.cmdBody(gl.tp.hp) + ') { ?>' + tpl + "<?php } ?>";
                break;
            case 'if':
                //if(this.cmdBody(gl) != '') ;
                tpl = "<?php if(" + this.cmdBody(gl.tp.hp) + ') { ?>' + tpl + "<?php } ";
                if(end.call(this, gl)) tpl += '?>';
                break;
            case 'elseif':
                tpl = "else if(" + this.cmdBody(gl.tp.hp) + ') { ?>' + tpl + "<?php } ";
                if(end.call(this, gl)) tpl += '?>';
                break;
            case 'else':
                tpl = "else(" + this.cmdBody(gl.tp.hp) + ') { ?>' + tpl + "<?php } ";
                if(end.call(this, gl)) tpl += '?>';
                break;
            case 'file':
                tpl += this.getFile(this.cmdBody(gl));
                break;
            case 'script':
                tpl = "<script>" + this.cmdBody(gl) + "</script>" ;
                break;
            case 'body':
                tpl = "<body>" + tpl + "</body>" ;
                break;
            case 'head':
                tpl = "<head>" + tpl + "</head>" ;
                break;
            case 'html':
                tpl = "<html>" + tpl + "</html>" ;
                break;
            case 'block':
                break;
            case 'code':
                tpl = "<?php" + this.cmdBody(gl) + "?>";
                break;
            default : break;
        }

        return tpl;
    },
    parseSyntax: function(code) {
        var boundChar = this.boundChar,
            leftBound = this.bound.left,
            rightBound = this.bound.right,
            command = this.command,
            NODETYPE_STR = 0, NODETYPE_OPEN = 1, NODETYPE_NODE = 2,

            tokens = [], begin = 0, forward = 0,
            forwardChar = '', func = '', codeLength = code.length,
            lastNode = null, currentNode = null, rightBoundBefore;

        while(forward < codeLength) { //每次吃进一个字符，只有边界和命令做为独立单元解析，其他统一当做普通字符串处理
            forwardChar = code.charAt(forward);
            if(forwardChar == leftBound) { //左边界
                forwardChar = code.charAt(++forward); //前进一个字符
                if(forwardChar == boundChar) { //如果左边界定位符匹配，进入命令解析
                    tokens.push({fn:'echo', begin:begin, forward:forward-1, nodeType:NODETYPE_STR}); //推入上一次结束边界到这次开始边界之间字符
                    begin = forward + 1; //起始指针位置加1
                    while(forwardChar = code.charAt(++forward)) {//这个循环寻找命令边界，找到结束，进行下一轮的正常扫描
                        if((isEChar(forwardChar) && trim(code.substring(begin, forward)) != '')
                            || (forwardChar == leftBound && code.charAt(forward+1) == boundChar)
                            || (forwardChar == boundChar && code.charAt(forward+1) == rightBound)) {
                            func = trim(code.substring(begin, forward));

                            if(command[func] == undefined || func == '') {
                                var rowNum = this.getLineNum(code.substring(0, forward)) + 1;
                                Set.Logger.error('function <' + func + '> not exists on <row:'+ rowNum +'>');
                                break;//抛出异常，函数不存在
                            }

                            tokens.push({fn:func, begin:begin, forward:forward, nodeType:NODETYPE_OPEN});
                            begin = forward;
                            forward --; //因为在总循环中forward要加1，所以这里要减去1，否则总循环扫描将错过一个字符
                            break;
                        }
                    }
                }
            } else if(forwardChar == rightBound) {//右边界
                forwardChar = code.charAt(forward - 1); //回溯匹配边界字符
                if(forwardChar == boundChar) {//碰到close边界出栈一个open边界，和边界之前的字符命令
                    rightBoundBefore = {fn:'echo', begin:begin, forward:forward-1, nodeType:NODETYPE_STR};
                    tokens.push(rightBoundBefore);
                    lastNode = currentNode = null;
                    while(currentNode = tokens.pop()) {
                        if(currentNode.nodeType == NODETYPE_OPEN) {
                            currentNode.tp = lastNode;
                            break;
                        } else {
                            currentNode.hp = lastNode;
                            lastNode = currentNode;
                        }
                    }

                    if(currentNode == null) {
                        var rowNum = this.getLineNum(code.substring(0, rightBoundBefore.forward)) + 1;
                        Set.Logger.error('open brace match error on <row:'+ rowNum +'>');
                    }
                    currentNode.nodeType = NODETYPE_NODE;
                    if(command[currentNode.fn] == NODETYPE_OPEN) {
                        rightBoundBefore.fn = 'str';
                    }
                    tokens.push(currentNode);
                    begin = forward + 1;
                }
            }
            forward++;
        }
        tokens.push({fn:'echo', begin:begin, forward:forward, nodeType:0});
        if(tokens.length>3) {
            var ln = tokens.length;
            while(ln-- >= 0) {
                if(tokens[ln].nodeType == NODETYPE_OPEN) {
                    var rowNum = this.getLineNum(code.substring(0, tokens[ln].forward)) + 1;
                    Set.Logger.error('close brace match error on <row:'+ rowNum +'>');
                }
            }
        }
        return tokens;
    },
    end: function(gl) {
        var end = true;
        while(gl = gl.hp) {
            if(this.command[gl.fn] == 3) {
                end = false;
            }
        }
        return end;
    },
    cmdBody: function(gl) {
        var mapFn = this.mapFn;
        this.mapFn = 'map1cmd';
        var tpl = this.t(gl.tp);
        this.mapFn = mapFn;
        return tpl;
    },
    t: function(gl) {
        if(!gl) return '';
        return this[this.mapFn](gl, this.t(gl.tp)) + this.t(gl.hp);
    },
    getLineNum: function(code) {
        var m = code.match(/\r\n/g);
        if(m) return m.length;
        return 0;
    },
    getFile: function(file) {
        file = trim(file);
        var p = this.parent;
        while(p != null) {
            if(p.name == file) Set.Logger.error('circle deps.')
            p = p.parent;
        }


        var fs = require('fs');
        var data = fs.readFileSync(file, 'utf8');

        var code = "{%block \n" + data + "%}";
        return New('class.compile.Compile').compile(code, {parent:this.parent, name:file});
    },

    forward: function() {
        var me = this;
        if (me.code.charAt(me.offset) == '\n') {
            me.line++;
            me.col = 0;
            me.offset++;
        } else {
            me.col++;
            me.offset++;
        }
    }


});
